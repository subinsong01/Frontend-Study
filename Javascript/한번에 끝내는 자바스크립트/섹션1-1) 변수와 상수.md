# 변수와 상수

### ✏️변수 = 변화하는 값을 저장하는 저장소(재할당 가능) <br />
대표적인 변수 = `let` <br />

**카멜표기법** : 첫번째 단어를 제외한 단어의 시작을 대문자로 표기하는 표기법(ex.userInfo)

### ✏️상수 = 변하지 않는 값을 저장하는 저장소(재할당 불가)
대표적인 상수 = `const`(ex.생일, 이름)


**✍🏻 여기서 중요한 부분**
<br />

변수를 선언하는데 const, let, var가 존재하는데 var를 지양하라는 이야기가 많은데 그 이유가 무엇일까? <br/>
바로 **1. 스코프, 2.호이스팅 동작 방식 차이, 3.의도 명확성** 문제 때문이다.

**1. 스코프**

- var는 함수 스코프를 갖는다.
- 블록({ }) 안에서 선언해도 블로 밖에서도 접근이 가능해서 의도치 않은 변수 오염 발생이 가능하다
- 하지만 `let`, `const` 경우에는 **블록 스코프**를 가져서 안전하다는 차이점이 있다.

```js
if (true) {
  var x = 1;
}
console.log(x); // 1 (블록 밖에서도 접근 가능)

if (true) {
  let y = 2;
}
console.log(y); // ReferenceError (블록 밖 접근 불가)
```
🧐 근데 여기서 궁금할 수 있다. let도 재선언이 가능하지 않나?! <br />
> 하지만 let은 블록스코프로 선언을 하기 때문에 var와는 큰 차이가 있다. 


**2. 호이스팅**
- var는 선언과 초기화가 동시에 호이스팅 되지 않고 선언만 호이스팅된다.그래서 변수를 선언하기 전에 접근하면 undefined가 나와서 버그 원인이 된다.
- let과 const는  **일시적 사각지대**에 있어서 선언 전에 접근하면 에러 발생

```js
console.log(x); // undefined
var x = 5;

console.log(y); // ReferenceError
let y = 5;
```
🧐 일시적 사각지대? <br />
> `let` 또는 `const`로 선언된 변수가 실제로 "선언되는 시점까지" 접근할 수 없는 구간을 의미한다.

```js
console.log(a); //ReferenceError
let a = 10;
```

a는 호이스팅되어 위로 끌어올려지긴 했지만 <br/>
실제 let a = 10이 실행되기 전까지는 접근할 수 없음
이 구간이 바로 "일시적 사각지대"

**var**

```js
console.log(b); // undefined
var b = 10;
```
var도 호이스팅되지만 초기화까지 함께 끌어올려짐 <br/>
그래서 선언 전에도 undefined로 접근 가능
하지만 이게 오히려 버그 유발 원인이라 let, const가 도입되었다.

**✨ TDZ가 중요한 이유**

- TDZ는 코드를 더 예측 가능하고 안전하게 만들어준다
- 선언 전 변수 사용 시 명확한 에러를 주기 때문에, 실수를 빠르게 잡을 수 있다
- let, const가 var보다 더 신뢰할 수 있는 변수 선언 방식인 이유 중 하나

**3.의도 명확성**

- const는 재할당 금지
- let은 재할당 가능
- var는 그런 구분 없이 모두 가능해서 코드 의도를 명확히 알기 어렵게 함


