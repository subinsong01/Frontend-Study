# 📂 정리
1. 가중치가 없으면? → `BFS : 큐`
2. 가중치가 모두 양수? → `다익스트라 : 우선순위 큐 `
3. 음수 가중치가 있음? → `벨만-포드`
4. 모든 정점 간 최단 경로? → `플로이드-워셜`

<img width="617" alt="스크린샷 2025-03-05 오후 12 51 48" src="https://github.com/user-attachments/assets/1aa1d497-eefb-408e-bc28-1055a3c15799" />

## 🚀 다익스트라

- 가중치가 있는 그래프에서 최단 경로 탐색 방법<br/>
 **다익스트라** : `모든 가중치가 양수 !` <br/>
 
✨ 우선순위 큐를 사용하여 탐색  
✨ 음수 가중치가 있으면 사용이 불가하다

## 📑 풀이 로직 
**1. 그래프를 인접 리스트로 저장**
- graph[u] = [[v, w], [v2, w2], ...] 형태
- 여러 개의 간선이 있을 수 있으므로 배열 사용 <br/>

**2. 우선순위 큐(Priority Queue) 활용**
- JavaScript에는 기본적으로 PriorityQueue가 없으므로, Min Heap을 직접 구현
  
**3. 거리 배열 초기화**
- distance[] 배열을 Infinity로 채운 후, 시작점 K는 0으로 설정
  
**4. 다익스트라 실행**
- heapq에서 가장 거리가 짧은 노드를 꺼내서, 인접한 노드들을 갱신

```js
class MinHeap(){
  constructor(){
    this.push = []
  }
  push(node){
    this.heap.push(node);
    this.heap.sort((a, b) => a[0] - b[0]); //가중치 기준 정렬
  }
  pop(){
    return this.heap.shift();
  }
  size(){
    return this.heap.length()l
  }
}

function dijkstra(V, edges, start){
  const INF = Infinity;
  const graph = Array.from({length : n + 1}, () => []);
  const distance = Array(V + 1).fill(INF);

  //그래프 초기화
  edges.forEach(([u, v, w]) => {
    graph[u].push([v, w]);
});
  
  const pq = new MinHeap();
  pq.push([0, start]); //(거리, 노드)
  distance[start] = 0;
   while (pq.size()) {
        const [dist, now] = pq.pop();

        // 이미 처리된 거리보다 크면 무시
        if (distance[now] < dist) continue;

        for (const [next, weight] of graph[now]) {
            const cost = dist + weight;
            if (cost < distance[next]) {
                distance[next] = cost;
                pq.push([cost, next]);
            }
        }
    }

    // 결과 출력
    return distance.map(d => (d === INF ? "INF" : d)).slice(1);
}

// 입력값
const V = 5, E = 6, start = 1;
const edges = [
    [5, 1, 1],
    [1, 2, 2],
    [1, 3, 3],
    [2, 3, 4],
    [2, 4, 5],
    [3, 4, 6]
];

// 실행
console.log(dijkstra(V, edges, start));
```


