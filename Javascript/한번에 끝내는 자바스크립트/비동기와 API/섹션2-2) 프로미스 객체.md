# Promise 객체
> 1. Promise는 "미래에 결과를 약속하는 객체" <br/>
> 2. 비동기 작업(시간이 걸리는 작업)을 다루기 위한 객체

- **`callback`** 지옥을 해결해준다

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("성공!"); // 성공 결과 반환
    // reject("실패!"); // 실패 시
  }, 1000);
});

promise
  .then(result => console.log("결과:", result)) // 성공 시 실행
  .catch(error => console.error("에러:", error)) // 실패 시 실행
  .finally(() => console.log("무조건 실행"));    // 항상 실행

```


| 상태       | 설명                                      |
|------------|-------------------------------------------|
| `pending`  | 대기 중 (아직 결과 없음)                  |
| `fulfilled`| 성공적으로 완료됨 (`resolve` 호출됨)      |
| `rejected` | 실패함 (`reject` 호출됨)                  |

 **Promise.all**
- 여러 개의 Promise를 병렬로 실행한다
- 전부 성공했을 때만 결과를 배열로 반환한다
- 하나라도 실패하면 전체가 실패한다
- 속도가 빠르다
  
```js
Promise.all([
  fetch("/api/user"),
  fetch("/api/posts"),
])
  .then(([userRes, postsRes]) => {
    console.log("둘 다 성공", userRes, postsRes);
  })
  .catch(err => {
    console.error("하나라도 실패하면 여기로:", err);
  });

//ex
const [user, posts] = await Promise.all([
  fetch("/api/user").then(r => r.json()),
  fetch("/api/posts").then(r => r.json())
]);
```
**Promise.allSettled**
- 여러 개의 Promise를 병렬 실행하지만
- 성공/실패 여부와 관계없이 전부 결과를 반환

```js
Promise.allSettled([
  fetch("/api/user"),
  fetch("/api/posts"),
])
  .then(results => {
    results.forEach(result => {
      if (result.status === "fulfilled") {
        console.log("성공:", result.value);
      } else {
        console.log("실패:", result.reason);
      }
    });
  });

//ex
const results = await Promise.allSettled([
  fetch("/api/user").then(r => r.json()),
  fetch("/api/posts").then(r => r.json())
]);

results.forEach(r => {
  if (r.status === "fulfilled") console.log("성공:", r.value);
  else console.log("실패:", r.reason);
});
```

**Promise.race**
- 여러 개의 Promise 중에서 가장 먼저 끝난 하나의 결과만 반환.
- 그게 성공이면 성공 반환, 실패면 실패 반환.

```js
Promise.race([
  fetch("/api/slow"),   // 3초 걸림
  fetch("/api/fast"),   // 1초 걸림
])
  .then(result => console.log("가장 빠른 성공:", result))
  .catch(err => console.error("가장 빠른 실패:", err));

//ex
const result = await Promise.race([
  fetch("https://server1.com/data"),
  fetch("https://server2.com/data"),
]);
```


----------------

### 리액트에서 사용 예시 

```jsx
import { useState, useEffect } from "react";
import axios from "axios";

export default function MyPage() {
  const [user, setUser] = useState(null);
  const [posts, setPosts] = useState([]);

  useEffect(() => {
    async function fetchData() {
      try {
        // 여러 API를 동시에 호출
        const [userRes, postsRes] = await Promise.all([
          axios.get("/api/user"),
          axios.get("/api/posts"),
        ]);

        setUser(userRes.data);
        setPosts(postsRes.data);
      } catch (err) {
        console.error("데이터 불러오기 실패", err);
      }
    }

    fetchData();
  }, []);

  return (
    <div>
      {user && <h1>{user.name} 님의 페이지</h1>}
      <ul>
        {posts.map(p => (
          <li key={p.id}>{p.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

### 뷰에서 사용 예시 (ref, onMounted 사용)
```vue
<template>
  <div>
    <h1 v-if="user">{{ user.name }} 님의 페이지</h1>
    <ul>
      <li v-for="p in posts" :key="p.id">{{ p.title }}</li>
    </ul>
  </div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import axios from "axios";

const user = ref(null);
const posts = ref([]);

onMounted(async () => {
  try {
    // 여러 API를 동시에 호출
    const [userRes, postsRes] = await Promise.all([
      axios.get("/api/user"),
      axios.get("/api/posts"),
    ]);

    user.value = userRes.data;
    posts.value = postsRes.data;
  } catch (err) {
    console.error("데이터 불러오기 실패", err);
  }
});
</script>
```
